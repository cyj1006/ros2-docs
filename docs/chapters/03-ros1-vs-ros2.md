# ROS2 的前身 ROS1



在前两章，我们已经知道：



- ROS2 是什么  

- ROS2 在系统中能干什么  



这一章我们要回答一个**很多新手都会问的问题**：



> **既然已经有 ROS1，为什么还要搞一个 ROS2？**



理解这一章，你就会明白：  

**ROS2 不是“升级版 ROS1”，而是一次从底层设计开始的重构。**



---



## 3.1 ROS1 是怎么来的



ROS1（通常直接叫 ROS）诞生于 **2007 年**，  

由 **斯坦福大学** 和 **Willow Garage** 推动开发。



当时机器人领域面临一个非常严重的问题：



!!! info "当年的真实困境"

&nbsp;   每个实验室、每个团队都在 **重复造轮子**。



- 同样的导航算法，不同团队各写一份  

- 接口不统一，代码无法复用  

- 研究成果难以共享  



ROS1 的出现，第一次在机器人领域做了三件事：



1. **统一通信方式**  

2. **统一代码组织结构**  

3. **推动大规模开源协作**



!!! success "历史地位"

&nbsp;   ROS1 让机器人领域第一次有了“通用语言”。



随着时间发展，ROS 社区：

- 累积了 **数千个功能包**

- 拥有 **数十万开发者**

- 成为机器人研究和教学的事实标准



---



## 3.2 ROS1 的先天问题



ROS1 很成功，但它的很多问题并不是“Bug”，  

而是 **在最初设计阶段就无法避免的限制**。



这些问题，在实验室还能忍，但在工程和工业场景中会非常致命。



---



### 3.2.1 单点故障问题（roscore）



ROS1 有一个核心组件叫 **roscore**。



- 所有节点都要通过它才能互相找到  

- 一旦 roscore 挂掉，整个系统立刻瘫痪  



!!! warning "工程级问题"

&nbsp;   在真实机器人系统中，**单点故障是不可接受的**。



---



### 3.2.2 不支持实时系统



很多工业机器人对时间非常敏感：



- 10 ms 内必须响应  

- 延迟过大会直接导致安全问题  



!!! info "现实限制"

&nbsp;   ROS1 在设计时并没有考虑实时性需求，  

&nbsp;   这使它难以进入工业级应用。



---



### 3.2.3 安全性几乎为零



ROS1 的默认设计是：



- 只要能连上网络  

- 谁都可以发布、订阅、控制机器人  



!!! danger "严重隐患"

&nbsp;   在公网或工业网络中，这是**严重的安全风险**。



---



### 3.2.4 平台支持受限



ROS1：

- 几乎只能在 Linux（Ubuntu）上完整运行  

- Python 依赖 Python 2（已停止维护）



这些问题，随着时间推移越来越难以接受。



---



## 3.3 ROS2 是如何解决这些问题的



ROS2 并不是在 ROS1 上“打补丁”，  

而是 **推倒重来，从架构层重新设计**。



---



### 去中心化通信（没有 roscore）



ROS2 基于 **DDS（数据分发服务）**：



!!! info "核心变化"

&nbsp;   节点之间 **直接发现、直接通信**，  

&nbsp;   不再依赖中心节点。



结果是：

- 没有单点故障  

- 系统更稳定  

- 更适合分布式部署  



---



### 支持实时系统



ROS2 在设计时就考虑了：



- 实时调度  

- 确定性通信  

- 工业控制需求  



这使 ROS2 能进入：

- 工业机器人  

- 自动化生产线  

- 对安全性要求极高的场景  



---



### 引入安全机制



ROS2 支持：

- 加密通信  

- 身份认证  

- 权限控制（DDS-Security）



!!! success "质变"

&nbsp;   ROS2 从“实验室工具”，  

&nbsp;   进化成 **可进入真实工程环境的系统框架**。



---



### 真正的跨平台



ROS2 原生支持：

- Linux  

- Windows  

- macOS  



并且 **Python 3 / C++ 并行支持**，彻底摆脱历史包袱。



---



## 3.4 ROS1 和 ROS2 的核心区别（对比表）



| 对比项 | ROS1 | ROS2 |

|------|-----|-----|

| 通信架构 | roscore 中心化 | DDS 去中心化 |

| 单点故障 | 有 | 无 |

| 实时性 | 不支持 | 支持 |

| 安全性 | 无 | 内置安全机制 |

| 平台支持 | Linux 为主 | 真正跨平台 |

| Python 版本 | Python 2 | Python 3 |

| 维护状态 | 已停止维护 | 持续活跃开发 |



---



## 3.5 应该学 ROS1 还是 ROS2？



!!! success "直接结论"

&nbsp;   **直接学 ROS2，不要犹豫。**



原因很简单：



- ROS1 已在 **2025 年停止官方支持**

- 新项目几乎全部基于 ROS2

- ROS2 的设计更符合现代软件工程



!!! info "唯一例外"

&nbsp;   只有在你需要维护 **历史 ROS1 项目** 时，  

&nbsp;   才需要了解 ROS1。



即便如此，**先学 ROS2 再回头看 ROS1，会更轻松**。



---



## 本章小结



通过这一章，你应该已经理解：



- ROS1 的历史价值非常重要  

- ROS1 的问题无法通过“小修小补”解决  

- ROS2 是一次系统级重构  

- 当前和未来的机器人开发，**应优先选择 ROS2**



---



## 下一章预告



下一章我们会进入一个**非常现实、也最容易踩坑的话题**：



> **为什么要选择 Ubuntu 20.04 / 22.04？**



我们会从系统、版本、兼容性角度，  

帮你避开新手最常掉进去的坑。



