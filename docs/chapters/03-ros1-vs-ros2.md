# 第三章：ROS2 的前身 ROS1——知道它从哪来

在前两章，我们已经知道：

- ROS2 是什么
- ROS2 在系统中能干什么

这一章我们要回答一个 **很多新手都会问的问题**：

!!! question "常见疑问"
    **既然已经有 ROS1，为什么还要搞一个 ROS2？**

理解这一章，你就会明白：

**ROS2 不是"升级版 ROS1"，而是一次从底层设计开始的重构。**

---

## 3.1 ROS1 是怎么来的

ROS1（通常直接叫 ROS）诞生于 **2007 年**，

由 **斯坦福大学** 和 **Willow Garage** 公司联合开发。

---

### 当年的真实困境

当时机器人领域面临一个非常严重的问题：

!!! warning "行业痛点"
    **每个实验室、每个团队都在重复造轮子。**

具体表现：

- 同样的导航算法，不同团队各写一份
- 接口不统一，代码无法复用
- 研究成果难以共享

---

### ROS1 的历史贡献

ROS1 的出现，第一次在机器人领域做了三件事：

#### 1. 统一通信方式

定义了标准的节点间通信协议

#### 2. 统一代码组织结构

规范了功能包的组织方式

#### 3. 推动大规模开源协作

建立了全球性的开发者社区

---

!!! success "历史地位"
    ROS1 让机器人领域第一次有了 **"通用语言"**。

---

### ROS1 的发展成果

随着时间发展，ROS 社区：

- 累积了 **数千个功能包**
- 拥有 **数十万开发者**
- 成为机器人研究和教学的 **事实标准**

---

## 3.2 ROS1 的先天问题

ROS1 很成功，但它的很多问题并不是"Bug"，

而是 **在最初设计阶段就无法避免的限制**。

!!! danger "核心矛盾"
    这些问题，在实验室还能忍，
    
    但在工程和工业场景中会 **非常致命**。

---

### 3.2.1 单点故障问题（roscore）

#### 什么是 roscore

ROS1 有一个核心组件叫 **roscore**。

- 所有节点都要通过它才能互相找到
- 一旦 roscore 挂掉，整个系统立刻瘫痪

---

#### 为什么这是问题

!!! danger "工程级问题"
    在真实机器人系统中，**单点故障是不可接受的**。

**实际场景：**

在工厂里，机器人突然全停了，那得损失多少钱？

---

### 3.2.2 不支持实时系统

很多工业机器人对时间非常敏感：

!!! warning "实时性要求"
    - 10 ms 内必须响应
    - 延迟过大会直接导致安全问题

---

#### ROS1 的局限

!!! info "现实限制"
    ROS1 在设计时并没有考虑实时性需求，
    
    这使它难以进入工业级应用。

---

### 3.2.3 安全性几乎为零

#### ROS1 的默认设计

- 只要能连上网络
- 谁都可以发布、订阅、控制机器人

---

#### 安全隐患

!!! danger "严重问题"
    在公网或工业网络中，
    
    这是 **严重的安全风险**。

**可能的后果：**

- 恶意控制
- 数据泄露
- 系统破坏

---

### 3.2.4 平台支持受限

#### ROS1 的限制

- 几乎只能在 Linux（Ubuntu）上完整运行
- Python 依赖 Python 2（已停止维护）

---

!!! warning "时代局限"
    这些问题，随着时间推移越来越难以接受。

---

## 3.3 ROS2 是如何解决这些问题的

ROS2 并不是在 ROS1 上"打补丁"，

而是 **推倒重来，从架构层重新设计**。

---

### 解决方案一：去中心化通信（没有 roscore）

#### 技术基础

ROS2 基于 **DDS（数据分发服务）**

---

#### 核心变化

!!! success "架构革新"
    节点之间 **直接发现、直接通信**，
    
    不再依赖中心节点。

---

#### 带来的好处

- ✓ 没有单点故障
- ✓ 系统更稳定
- ✓ 更适合分布式部署

---

### 解决方案二：支持实时系统

#### ROS2 的设计考虑

- 实时调度
- 确定性通信
- 工业控制需求

---

#### 应用场景拓展

这使 ROS2 能进入：

- 工业机器人
- 自动化生产线
- 对安全性要求极高的场景

---

### 解决方案三：引入安全机制

#### ROS2 的安全特性

- 加密通信
- 身份认证
- 权限控制（DDS-Security）

---

!!! success "质的飞跃"
    ROS2 从"实验室工具"，
    
    进化成 **可进入真实工程环境的系统框架**。

---

### 解决方案四：真正的跨平台

#### ROS2 原生支持

- ✓ Linux
- ✓ Windows
- ✓ macOS

---

#### 语言支持

- ✓ Python 3
- ✓ C++

**彻底摆脱历史包袱。**

---

## 3.4 ROS1 和 ROS2 的核心区别（对比表）

| 对比项 | ROS1 | ROS2 |
|--------|------|------|
| **通信架构** | roscore 中心化 | DDS 去中心化 |
| **单点故障** | 有 | 无 |
| **实时性** | 不支持 | 支持 |
| **安全性** | 无 | 内置安全机制 |
| **平台支持** | Linux 为主 | 真正跨平台 |
| **Python 版本** | Python 2 | Python 3 |
| **维护状态** | 已停止维护 | 持续活跃开发 |

---

## 3.5 应该学 ROS1 还是 ROS2？

!!! success "直接结论"
    **直接学 ROS2，不要犹豫。**

---

### 原因很简单

#### 1. ROS1 已停止支持

- ROS1 在 **2025 年停止官方支持**
- 新项目几乎全部基于 ROS2

---

#### 2. ROS2 设计更现代

- 符合现代软件工程理念
- 更适合工程化应用

---

#### 3. 学习路径更优

!!! tip "学习建议"
    **先学 ROS2 再回头看 ROS1，会更轻松**

---

### 唯一的例外

!!! info "特殊情况"
    只有在你需要维护 **历史 ROS1 项目** 时，
    
    才需要了解 ROS1。

即便如此，也建议：

1. 先学 ROS2
2. 再按需了解 ROS1 的差异

---

## 3.6 ROS1 到 ROS2 的迁移

### 为什么要迁移

如果你的实验室或公司有 ROS1 项目：

!!! warning "现实考虑"
    - ROS1 不再维护
    - 安全性问题
    - 新功能无法享受

迁移到 ROS2 是必然趋势。

---

### 迁移难度

!!! info "实际情况"
    - 概念基本相同
    - API 有一定变化
    - 需要重新编译
    - 部分功能包可能需要重写

---

### 官方迁移指南

ROS2 官方提供了详细的迁移文档：

- 概念对照表
- API 变化说明
- 常见问题解答
- 自动化迁移工具

---

## 本章小结

通过这一章，你应该已经理解：

1. **ROS1 的历史价值**
   - 统一了机器人领域的开发方式
   - 建立了强大的开源社区

2. **ROS1 的问题无法通过"小修小补"解决**
   - 单点故障
   - 不支持实时限

3. **ROS2 是一次系统级重构**
   - 去中心化架构
   - 实时性支持
   - 内置安全机制
   - 真正跨平台

4. **当前和未来的机器人开发，应优先选择 ROS2**

---

## 下一章预告

下一章我们会进入一个 **非常现实、也最容易踩坑的话题**：

> **为什么要选择 Ubuntu 20.04 / 22.04？**

我们会从系统、版本、兼容性角度，

帮你避开新手最常掉进去的坑。

